# 宿舍分配程序



## 好处

1.   最小化loss——程序会尽可能找到一个最优分配方案
2.   去中心化——分配方案由所有人决定，而不是由少数人决定
3.   隐私保护——上传数据加密，保证偏好不会被公开
4.   代码公开——分配程序代码会公开，从而确保公正性



## 隐私算法

main.py 内部会生成publicKey 与 privateKey, 并会打印出publicKey供同学们加密。privateKey一直保护在内存中，任何时候都不会有人知道。（因此程序不能关掉，得一直挂着）

同学们加密完了以后吧所有文件给main.py以供解密并运算（程序当然也不会输出解密的中间结果）

必须确保main.py不被伪造。为此，在运行前使用github中新拉下来的main.py来确保正确性，或者用md5验证也可。



### 隐私QA：

Q：我提交的文档不会泄漏隐私吗？

A ：你提交的文档是经过你使用管理者下发的publicKey加密的。

Q：我怎么保证管理者不会解密我的文档？

A：main.py只会产生打印publicKey，privateKey存在程序的内存中无人知道。因此，你的文档除了用作该进程的数据输入并生成宿舍分配表，无法被用来做任何其它的事。

Q：我怎么保证管理者真的使用main.py来产生公钥？

A：下载并运行可信的main.py，生成公钥，并将公钥公布至班群，这一行为是由多位同学公证的。



## 分配算法

每个人填写一个偏好，最终分配结果按照所有人的偏好共同决定。

每人的偏好加密后上传，上传后在程序内部解密（私钥一直保存在内存中），程序只会输出分配方案。

bias_i=x\*对每个人的打分（0-10之间的整数） + y*对标签的偏好（0-10之间的整数）+ 对几人寝的偏好（一定是每个人都是四人寝吗？待定），x,y也是每个人自己控制的，且有 $0\leq x+y\leq 10$

标签种类事先班群中收集，如，几点起，等等。

每人对自己与所有标签的符合度进行打分，与对所有其它人的偏好进行打分。

$loss = \sum happy_i$, $happy_i$为i对i所住寝室其余人的平均偏好。

另一种loss为

$loss=\sum bias_i(j)$,ij枚举所有在同一寝室的人的pair。

系统将各种东西最终都归结为偏好矩阵，然后使用优化算法，如模拟退火，以生成结果。



### 需求QA：

Q：我如果一定要与某位同学在一个宿舍怎么办呢？

A：你可以将“人”的权值拉满，将该同学的权重拉满，将其它同学的权重置零。

Q：我们寝室都不想换室友，怎么办呢？

A：你们可以将“人”的权值拉满，将你们室友的权重拉满，将其它同学的权重置零。

Q：我必须早睡，怎么填？

A：你可以将“标签”的权值拉满，将自己的将“早睡”标签拉满，“晚睡”标签置零。将自己偏好的“早睡”标签拉满，“晚睡”标签置零。

其余需求类似。



如果有该机制无法解决的需求，可与开发者联系。如果需要增删查改标签，可共同讨论。



## 格式范围检验：

在同学端和管理者端皆有格式与数值范围检查。

main.py与encryptor.py都会对所有输入文件将进行**严格的格式与数值范围检查**。如果某文件解密或格式或数值范围有错误将会提醒，直到通过。



## 使用方法

先下发偏好表格，同学们可以预先填完。同时，管理者预先给同学下发encryptor.py（同学和管理者都需要预先安装rsa库）

管理者在数个同学的监督下运行main.py（监督确保运行者运行的确实是main.py而不是自己的代码）程序会生成一个数字（公钥）pub存放在文件中。之后程序**仍然运行，在搜集完同学的数据并打印出方案前请不要关闭，不然要重来一遍**！

同学们**在较短时间内**（时间越长，程序在后台挂着的时间越长，越容易出意外）将预先填好的表格，下发的pub文件与encryptor.py放在同一个文件下，然后运行encryptor.py来生成加密文件，然后提交给管理者。**确保所有人都正确提交，不然要重来一遍**。

管理者确认所有同学都正确填写并提交后将所有提交后的文件放在main.py同级的地方，然后输入'y'确认。

之后等待一段时间即会生成分配方案。
